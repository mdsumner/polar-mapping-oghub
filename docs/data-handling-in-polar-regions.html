<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="4 Data handling in polar regions | Challenges working with data in polar regions" />
<meta property="og:type" content="book" />


<meta property="og:description" content="4 Data handling in polar regions | Challenges working with data in polar regions." />


<meta name="author" content="Michael Sumner" />



<meta name="description" content="4 Data handling in polar regions | Challenges working with data in polar regions.">

<title>4 Data handling in polar regions | Challenges working with data in polar regions</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
</style>
</head>

<body>

<div class="container-fluid main-container">


<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li class="has-sub"><a href="index.html#about-this"><span class="toc-section-number">1</span> About this</a><ul>
<li class="has-sub"><a href="index.html#description-and-objectives"><span class="toc-section-number">1.1</span> Description and objectives</a><ul>
<li><a href="index.html#references"><span class="toc-section-number">1.1.1</span> References</a></li>
</ul></li>
</ul></li>
<li><a href="getting-set-up.html#getting-set-up"><span class="toc-section-number">2</span> Getting Set Up</a></li>
<li class="has-sub"><a href="polar-maps.html#polar-maps"><span class="toc-section-number">3</span> Polar maps</a><ul>
<li><a href="polar-maps.html#mapping-in-r"><span class="toc-section-number">3.1</span> Mapping in R</a></li>
<li><a href="polar-maps.html#exercises-01"><span class="toc-section-number">3.2</span> Exercises 01</a></li>
<li><a href="polar-maps.html#lets-use-the-maps-data"><span class="toc-section-number">3.3</span> Let’s use the maps data!</a></li>
<li><a href="polar-maps.html#reprojecting-to-polar-regions"><span class="toc-section-number">3.4</span> Reprojecting to polar regions</a></li>
<li><a href="polar-maps.html#demonstration-of-the-projection-concept"><span class="toc-section-number">3.5</span> Demonstration of the projection concept</a></li>
</ul></li>
<li class="has-sub"><a href="data-handling-in-polar-regions.html#data-handling-in-polar-regions"><span class="toc-section-number">4</span> Data handling in polar regions</a><ul>
<li><a href="data-handling-in-polar-regions.html#overlay-between-different-projections"><span class="toc-section-number">4.1</span> Overlay between different projections</a></li>
<li><a href="data-handling-in-polar-regions.html#build-an-index-betweeen-the-raw-raster-data-and-the-polar-map-regions"><span class="toc-section-number">4.2</span> Build an index betweeen the raw raster data and the polar map regions</a></li>
</ul></li>
<li class="has-sub"><a href="somap.html#somap"><span class="toc-section-number">5</span> SOmap</a><ul>
<li><a href="somap.html#circumpolar-maps"><span class="toc-section-number">5.1</span> Circumpolar maps</a></li>
<li><a href="somap.html#adding-points"><span class="toc-section-number">5.2</span> Adding points</a></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="data-handling-in-polar-regions" class="section level1">
<h1><span class="header-section-number">4</span> Data handling in polar regions</h1>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">load</span>(<span class="st">&quot;polar-mapping.Rdata&quot;</span>)  <span class="co">## see getting-set-up</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="kw">library</span>(dplyr)</a></code></pre></div>
<p>In practice, these kinds of problems in polar data mean that careful choices be made. For an involved whole-ecosystem assessment publication we generated a partition of the marine region of the Southern Ocean.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">plot</span>(aes_zone, <span class="dt">col =</span> aes_zone<span class="op">$</span>colour)</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="kw">abline</span>(<span class="dt">v =</span> <span class="dv">0</span>, <span class="dt">lty =</span> <span class="dv">2</span>)</a></code></pre></div>
<p><img src="_main_files/figure-html/ace-ecostats-1.png" width="672" /></p>
<p>This was easy for mapping sea ice concentration, we have daily remote sensing maps of southern ocean sea ice and it’s trivial to reproject our polygons onto those.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">library</span>(raster)</a>
<a class="sourceLine" id="cb33-2" data-line-number="2"><span class="kw">plot</span>(sea_ice)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"><span class="kw">plot</span>(<span class="kw">spTransform</span>(aes_zone, raster<span class="op">::</span><span class="kw">projection</span>(sea_ice)), <span class="dt">add =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p><img src="_main_files/figure-html/example-ice-1.png" width="672" /></p>
<p>But when it comes to sea surface temperature, these data have a number of issues.</p>
<p>One is that the data is natively in [0, 360] longitude range and if we project these data to our polar map we lose the western hemisphere.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" data-line-number="1">rtemp &lt;-<span class="st"> </span><span class="kw">raster</span>(aes_zone, <span class="dt">res =</span> <span class="dv">25000</span>)</a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="kw">plot</span>(<span class="kw">projectRaster</span>(sea_temp, rtemp))</a></code></pre></div>
<pre><code>## Warning in rgdal::rawTransform(projfrom, projto, nrow(xy), xy[, 1], xy[, :
## 53 projected point(s) not finite</code></pre>
<p><img src="_main_files/figure-html/example-sst-1.png" width="672" /></p>
<p>The solution to <em>that problem</em> is to shift the part of the raster that is over the dateline back to the west</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1">sea_temp180 &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">rotate</span>(sea_temp)</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="kw">plot</span>(<span class="kw">projectRaster</span>(sea_temp180, rtemp))</a></code></pre></div>
<pre><code>## Warning in rgdal::rawTransform(projfrom, projto, nrow(xy), xy[, 1], xy[, :
## 53 projected point(s) not finite</code></pre>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">plot</span>(aes_zone, <span class="dt">add =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p><img src="_main_files/figure-html/example2-sst-1.png" width="672" /></p>
<p>On the face of it this means we now have an easy job, simply project every sea surface temperature raster onto this polar map and then do the extraction.</p>
<p>But, this is going to be slow, it’s a lot of work to reproject 10000+ raster grids, and it inevitably involves resampling (remodelling) of the underlying data, imposing assumptions about what the data means. This is more important for other quantities like wind speeds and water flow directions, but is for the same ultimate reasons.</p>
<div id="overlay-between-different-projections" class="section level2">
<h2><span class="header-section-number">4.1</span> Overlay between different projections</h2>
<p>This is what the overlay process would be like, and we might think we can inverse-transform our polar polygons to this.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">plot</span>(sea_temp180)</a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="kw">plot</span>(aes_zone_ll, <span class="dt">add =</span><span class="ot">TRUE</span>)</a></code></pre></div>
<p><img src="_main_files/figure-html/native-grid-1.png" width="672" /></p>
<p>But, it doesn’t look good. This is because the polar region that crosses the dateline is a single polygon, but in this projection it must be split in two pieces. This is why there is two objects <code>aes_zone</code> and <code>aes_zone_ll</code>. It can be a bit of work to construct these two versions but in our experience it really made things simpler, there’s simply a one-to-one relationship between the to data sets, one in longitude/latitude, and one in polar map coordinates.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">plot</span>(sea_temp180)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="kw">plot</span>(<span class="kw">spTransform</span>(aes_zone, raster<span class="op">::</span><span class="kw">projection</span>(sea_temp180)), <span class="dt">add =</span><span class="ot">TRUE</span>)</a></code></pre></div>
<p><img src="_main_files/figure-html/native-grid2-1.png" width="672" /></p>
</div>
<div id="build-an-index-betweeen-the-raw-raster-data-and-the-polar-map-regions" class="section level2">
<h2><span class="header-section-number">4.2</span> Build an index betweeen the raw raster data and the polar map regions</h2>
<p>This is a really powerful trick for processing spatial data in R, and boils down to performing the extraction from the raster data in the native grid.</p>
<p>Every pixel is the sea surface temperature data has a unique relationship with each polygon, it either belongs inside a single polygon or not. So we create this index by <strong>rasterizing</strong> the polygons into the grid. This seems backwards, but it means we now now which polygon every pixel belongs to.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1">aes_zone_ll<span class="op">$</span>row &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(aes_zone_ll)</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">raster_polys &lt;-<span class="st"> </span>fasterize<span class="op">::</span><span class="kw">fasterize</span>(sf<span class="op">::</span><span class="kw">st_as_sf</span>(aes_zone_ll), sea_temp180, <span class="dt">field =</span> <span class="st">&quot;row&quot;</span>)</a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="kw">plot</span>(raster_polys)</a></code></pre></div>
<p><img src="_main_files/figure-html/fasterize-1.png" width="672" /></p>
<p>That is all the “geometry lookup” work required done. We can produce an index between raster cell and polygon in a simple table.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1">cell &lt;-<span class="st"> </span>tibble<span class="op">::</span><span class="kw">tibble</span>(<span class="dt">polygon =</span> raster<span class="op">::</span><span class="kw">values</span>(raster_polys), <span class="dt">cell =</span> <span class="dv">1</span><span class="op">:</span><span class="kw">ncell</span>(raster_polys))</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">cell</a></code></pre></div>
<pre><code>## # A tibble: 1,036,800 x 2
##    polygon  cell
##      &lt;dbl&gt; &lt;int&gt;
##  1      NA     1
##  2      NA     2
##  3      NA     3
##  4      NA     4
##  5      NA     5
##  6      NA     6
##  7      NA     7
##  8      NA     8
##  9      NA     9
## 10      NA    10
## # … with 1,036,790 more rows</code></pre>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="co">## we don&#39;t need very cell, the most southerly region is NA as is anything north of 20S</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">cell &lt;-<span class="st"> </span>dplyr<span class="op">::</span><span class="kw">filter</span>(cell, <span class="op">!</span><span class="kw">is.na</span>(polygon))</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">cell</a></code></pre></div>
<pre><code>## # A tibble: 230,383 x 2
##    polygon   cell
##      &lt;dbl&gt;  &lt;int&gt;
##  1      12 691201
##  2      12 691202
##  3      12 691203
##  4      12 691204
##  5      12 691205
##  6      12 691206
##  7      12 691207
##  8      12 691208
##  9      12 691209
## 10      12 691210
## # … with 230,373 more rows</code></pre>
<p>To extract the values for this index we use <code>cell</code> and this takes very little time:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" data-line-number="1">cell<span class="op">$</span>sst &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">extract</span>(sea_temp180, cell<span class="op">$</span>cell)</a>
<a class="sourceLine" id="cb46-2" data-line-number="2"></a>
<a class="sourceLine" id="cb46-3" data-line-number="3"></a>
<a class="sourceLine" id="cb46-4" data-line-number="4">cell <span class="op">%&gt;%</span><span class="st"> </span>dplyr<span class="op">::</span><span class="kw">group_by</span>(polygon) <span class="op">%&gt;%</span><span class="st"> </span>dplyr<span class="op">::</span><span class="kw">summarize</span>(<span class="dt">mean =</span> <span class="kw">mean</span>(sst, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>), </a>
<a class="sourceLine" id="cb46-5" data-line-number="5">                                                       <span class="dt">sd =</span> <span class="kw">sd</span>(sst, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>), </a>
<a class="sourceLine" id="cb46-6" data-line-number="6">                                                       <span class="dt">min =</span> <span class="kw">min</span>(sst, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>), </a>
<a class="sourceLine" id="cb46-7" data-line-number="7">                                                       <span class="dt">max =</span> <span class="kw">max</span>(sst, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a></code></pre></div>
<pre><code>## # A tibble: 12 x 5
##    polygon   mean     sd    min   max
##      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1       1  1.01  3.59   -1.80  13.6 
##  2       2 -1.76  0.0760 -1.80  -1.07
##  3       3 13.5   4.36   -1.37  23.3 
##  4       4  0.435 2.10   -1.80   5.09
##  5       5 -1.69  0.114  -1.79  -1.16
##  6       6  9.96  3.82    2.92  19.3 
##  7       7  1.91  3.60   -1.80  15.5 
##  8       8 -1.75  0.0481 -1.80  -1.47
##  9       9 12.2   3.59    1.37  21.1 
## 10      10 -0.440 2.02   -1.80   9.10
## 11      11 -1.76  0.0367 -1.80  -1.48
## 12      12 11.3   4.66   -0.770 22.6</code></pre>
<p>If we ran this using raster directly, it takes quite some time for a single layer and a single statistic, and if we have a lot of time slices it will really add up.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">system.time</span>(raster<span class="op">::</span><span class="kw">extract</span>(sea_temp180, aes_zone_ll, <span class="dt">fun =</span> mean, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb48-2" data-line-number="2"><span class="co">##   user  system elapsed </span></a>
<a class="sourceLine" id="cb48-3" data-line-number="3"><span class="co">## 18.331   0.164  18.502 </span></a></code></pre></div>

</div>
</div>
<p style="text-align: center;">
<a href="polar-maps.html"><button class="btn btn-default">Previous</button></a>
<a href="somap.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>


</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

</body>
</html>
