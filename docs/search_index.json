[
["index.html", "Challenges working with data in polar regions 1 About this", " Challenges working with data in polar regions Michael Sumner 1 About this This workshop is for R users interested in mapping in polar regions. "],
["getting-set-up.html", "2 Getting Set Up", " 2 Getting Set Up We need the latest versions of these R packages installed from GitHub. It’s best to run each line in turn in case there are issues or the user needs to provide input. ## make sure we have the packages we need if (!requireNamespace(&quot;remotes&quot;, quietly = TRUE)) { install.packages(&quot;remotes&quot;) } req1 &lt;- c(&quot;ggplot2&quot;, &quot;maps&quot;, &quot;maptools&quot;, &quot;raster&quot;, &quot;sp&quot;) remotes::install_cran(req1) "],
["overview.html", "3 Overview", " 3 Overview What is required for mapping in polar regions? shape-feature orientations, the dateline and the poles handling of data in long-lat, understanding of metrics and shape (area, length, angle) projected maps can be very hard to do, each has its own issues quantities like vector fields conventions for globabl data -180/180, 0/360 "],
["mapping.html", "4 Mapping 4.1 Maps in R 4.2 Reprojecting to polar regions 4.3 SOmap 4.4 Supporting data for maps", " 4 Mapping 4.1 Maps in R The oldest and most core general mapping package in R is the maps package. It has a simple whole-world coastline data set for immediate use. maps::map() The data underlying this live map is available by capturing the output as an actual object. Notice that the coastline for Antarctica does not extend to the south pole, and that parts of Russia that are east of 180 longitude are not in the western part of the map. m &lt;- maps::map(plot = FALSE) lonlat &lt;- cbind(m$x, m$y) plot(lonlat, pch = &quot;+&quot;, cex = 0.4, axes = FALSE) lines(lonlat, col = &quot;dodgerblue&quot;) abline(h = c(-90, 90), v = c(-180, 180)) A very similar and more modern data set is available in the maptools package. data(&quot;wrld_simpl&quot;, package = &quot;maptools&quot;) library(sp) plot(wrld_simpl) This data set aligns exactly to the conventional -180/180 -90/90 extent of the longitude/latitude projection. plot(0, type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, xlim = c(-180, 180), ylim = c(-90, 90)) rect(xleft = -180, ybottom = -90, xright = 180, ytop = 90, border = &quot;darkred&quot;, lwd = 4, lty = 2) plot(wrld_simpl, add = TRUE) 4.1.1 Exercises How can we find the longitude and latitude ranges of the maps data m and the maptools data wrld_simpl? Can we draw polygons with a fill colour with the maps package? Answer 1: range(m$x, na.rm = TRUE) range(m$y, na.rm = TRUE) also m$range Answer 2: polygon(lonlat, col = &quot;grey&quot;) does not work, and map(mp, fill = TRUE, col = &quot;grey&quot;) does not work, but maps::map(fill = TRUE, col = &quot;grey&quot;) does seem to work. What’s going on? Look at the very south-eastern corner of the map. The “coastline” has been extended to the very south boundary of the available area. plot(0, type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, xlim = c(-150, 180), ylim = c(-90, -60)) plot(wrld_simpl, add = TRUE, col = &quot;grey&quot;) rect(xleft = -180, ybottom = -90, xright = 180, ytop = 90, border = &quot;darkred&quot;, lwd = 4, lty = 2) maps::map(add = TRUE, col = &quot;dodgerblue&quot;, lwd = 3) When we add the old maps coastline see that it does not extend to 90S and it does not traverse the southern boundary. One reason for this is that if we choose a projection where the east and west edges of the Antarctic coastline meet then we get what looks a fairly clean join. ## scale factor f &lt;- 3e6 plot(rgdal::project(lonlat, &quot;+proj=laea +lat_0=-90 +datum=WGS84&quot;), asp = 1, type = &quot;l&quot;, xlim = c(-1, 1) * f, ylim = c(-1, 1) * f, xlab = &quot;&quot;, ylab = &quot;&quot;) If we try the same with wrld_simpl it’s not as neat. We have a strange “seam” that points exactly to the south pole (our projection is centred on longitude = 0, and latitude = -90. plot(sp::spTransform(wrld_simpl, &quot;+proj=laea +lat_0=-90 +datum=WGS84&quot;), asp = 1, xlim = c(-1, 1) * f, ylim = c(-1, 1) * f, xlab = &quot;&quot;, ylab = &quot;&quot;, lwd = 3) abline(v = 0, h = 0, lty = 2, col = &quot;grey&quot;) 4.1.2 Let’s use the maps data! In m we have the maps data structure, and this looks promising. str(m) ## List of 4 ## $ x : num [1:82403] -69.9 -69.9 -69.9 -70 -70.1 ... ## $ y : num [1:82403] 12.5 12.4 12.4 12.5 12.5 ... ## $ range: num [1:4] -180 190.3 -85.2 83.6 ## $ names: chr [1:1627] &quot;Aruba&quot; &quot;Afghanistan&quot; &quot;Angola&quot; &quot;Angola:Cabinda&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;map&quot; mp &lt;- m pxy &lt;- rgdal::project(lonlat, &quot;+proj=laea +lat_0=-90 +datum=WGS84&quot;) mp$x &lt;- pxy[,1] mp$y &lt;- pxy[,2] mp$range &lt;- c(range(mp$x,na.rm = TRUE), range(mp$y, na.rm = TRUE)) mp$range ## [1] -12709814 12704237 -12576156 12470787 plot(c(-1, 1) * f, c(-1, 1) * f, type = &quot;n&quot;, asp = 1) maps::map(mp, add = TRUE) ## but it doesn&#39;t take much to go awry plot(c(-1, 1) * f, c(-1, 1) * f, type = &quot;n&quot;, asp = 1) maps::map(mp, add = TRUE, fill = TRUE, col = &quot;grey&quot;) The problem is that the maps database has enough internal structure to join lines correctly, with NA gaps between different connected linestrings, but not enough to draw these things as polygons. A similar problem occurs in the default projection. While wrld_simpl has been extend by placing two dummy coordinates at the east and west versions of the south pole, this data set does not have those. We have to look quite carefully to understand what is happening, but this is wrapping around overlapping itself and so close to the southern bound we barely notice. plot(0, type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, xlim = c(-180, -110), ylim = c(-90, -60)) rect(xleft = -180, ybottom = -90, xright = 180, ytop = 90, border = &quot;darkred&quot;, lwd = 4, lty = 2) maps::map(add = TRUE,col = &quot;grey&quot;, fill = TRUE) maps::map(col = &quot;grey&quot;, fill = TRUE) mpmerc &lt;- m pxy &lt;- rgdal::project(lonlat, &quot;+proj=merc +datum=WGS84&quot;) mpmerc$x &lt;- pxy[,1] mpmerc$y &lt;- pxy[,2] mpmerc$range &lt;- c(range(mpmerc$x,na.rm = TRUE), range(mpmerc$y, na.rm = TRUE)) mpmerc$range ## [1] -20037508 20037508 -20179524 18351859 ## the catastrophe made a little clearer plot(0, xlim = range(mpmerc$range[1:2]), ylim = c(mpmerc$range[1], 0)) maps::map(mpmerc, fill = TRUE, col = &quot;grey&quot;, add = TRUE) 4.2 Reprojecting to polar regions In essence it should be easy, but details really matter. sst &lt;- raster::raster(system.file(&quot;nc/reduced.nc&quot;, package = &quot;stars&quot;, mustWork = TRUE)) ## Warning in .varName(nc, varname, warn = warn): varname used is: sst ## If that is not correct, you can set it to one of: sst, anom, err, ice library(raster) plot(raster::projectRaster(sst, crs = &quot;+proj=laea +lat_0=-90&quot;)) ## Warning in rgdal::rawTransform(projfrom, projto, nrow(xy), xy[, 1], xy[, : ## 48 projected point(s) not finite ## Warning in rgdal::rawTransform(projto_int, projfrom, nrow(xy), xy[, 1], : ## 6211 projected point(s) not finite plot(raster::projectRaster(rotate(sst), crs = &quot;+proj=laea +lat_0=-90&quot;)) ## Warning in rgdal::rawTransform(projfrom, projto, nrow(xy), xy[, 1], xy[, : ## 48 projected point(s) not finite ## Warning in rgdal::rawTransform(projto_int, projfrom, nrow(xy), xy[, 1], : ## 6213 projected point(s) not finite 4.3 SOmap The SOmap package is intended to solve some of these problems, and provide an easier way to produce nice-looking maps of Antarctica and the Southern Ocean. It is primarily focused on maps in polar stereographic projection (although the SOmap_auto function extends this to other projections). SOmap won’t necessarily get you exactly the map you want. But if it doesn’t, it should hopefully get you close enough that you can make modifications to suit your exact purposes. Please bear in mind that SOmap is still in development, and so its functionality (function parameters and/or behaviour) may change. By default, SOmap works with base graphics (and associated functionality from packages such as raster and sp). It is also possible to work with ggplot2-based graphics, as described below. Start by loading the SOmap package: library(SOmap) ## also define a colour map to use for some examples my_cmap &lt;- colorRampPalette(c(&quot;#4D4140&quot;, &quot;#596F7E&quot;, &quot;#168B98&quot;, &quot;#ED5B67&quot;, &quot;#E27766&quot;, &quot;#DAAD50&quot;, &quot;#EAC3A6&quot;))(51) 4.3.1 Circumpolar maps A basic circumpolar map in polar stereographic projection: SOmap() SOmanagement() provides a number of contextual layers such as MPA boundaries and management zones. SOmap(trim = -40) ## plot to 40S ## add the exclusive economic zones management layer SOmanagement(eez = TRUE) 4.3.1.1 Adding points ## some longitude/latitude data library(sp) my_points_ll &lt;- data.frame(lon = seq(0, 350, by = 10), lat = -55, z = runif(36)) coordinates(my_points_ll) &lt;- c(&quot;lon&quot;, &quot;lat&quot;) projection(my_points_ll) &lt;- &quot;+proj=longlat +datum=WGS84&quot; This needs to be reprojected to match our map before plotting. The SOproj function does this: ## reproject to our SOmap projection my_points &lt;- SOproj(my_points_ll) ## and plot SOmap() plot(my_points, col = &quot;blue&quot;, add = TRUE) Or use SOplot to reproject and plot in one step: SOmap() SOplot(my_points_ll, col = &quot;blue&quot;) 4.3.1.2 Adding raster layers First let’s construct some artificial raster data (in longitude-latitude space) for demonstration purposes: library(raster) temp &lt;- as.data.frame(expand.grid(lon = seq(100, 140, by = 0.25), lat = seq(-65, -45, by = 0.1))) temp$val &lt;- sqrt((temp$lon - 120)^2/3 + (temp$lat - -40)^2/5) ## create raster object xr &lt;- rasterFromXYZ(temp) projection(xr) &lt;- &quot;+proj=longlat +datum=WGS84&quot; SOplot will reproject and plot this for us: SOmap() SOplot(xr) The legend is out of character with the rest of the map. We can use SOleg to fix that: ## draw the base map SOmap() ## add our raster SOplot(xr, legend = FALSE, col = my_cmap) ## add the legend SOleg(xr, position = &quot;topright&quot;, col = my_cmap, ticks = 6, type = &quot;continuous&quot;, label = &quot;My variable&quot;) OK, well that worked but clearly the labels need tidying up. We can do that, but we have to be careful to make sure that the colour range of the legend matches that of the plotted raster. ## draw the base map SOmap() ## add our raster, controlling the colour range to span the values 0 to 30 colour_breaks &lt;- seq(0, 30, length.out = length(my_cmap) + 1) SOplot(xr, legend = FALSE, col = my_cmap, breaks = colour_breaks) ## add the legend, again controlling the colour range label_breaks &lt;- seq(0, 30, length.out = 7) SOleg(position = &quot;topright&quot;, col = my_cmap, breaks = label_breaks, type = &quot;continuous&quot;, label = &quot;My variable&quot;) Note that if we don’t want to show the bathymetric legend, we may run into problems: SOmap(bathy_legend = FALSE) ## suppress the bathy legend SOleg(position = &quot;topright&quot;, col = my_cmap, breaks = label_breaks, type = &quot;continuous&quot;, label = &quot;My variable&quot;) The legend has been chopped off because the layout has not left enough space around the map for the curved legend. Currently, the best solution is probably to generate the SOmap object with the bathymetric legend, but then remove it before plotting (see the Modifying map objects section for more details on this): temp &lt;- SOmap() temp$bathy_legend &lt;- NULL ## remove the bathy legend plot(temp) SOleg(position = &quot;topright&quot;, col = my_cmap, breaks = label_breaks, type = &quot;continuous&quot;, label = &quot;My variable&quot;) Multiple rasters: xr2 &lt;- raster::shift(xr, -70) ## offset in longitude SOmap() SOplot(xr, legend = FALSE, col = my_cmap) SOplot(xr2, legend = FALSE, col = my_cmap) 4.3.2 Non-circumpolar maps The SOmap_auto function will take your input data and make a guess at an appropriate projection and extent to use. Note that this is not always going to guess the best projection and extent, so you should view it as a starting point from which you can generate a map to your exact requirements. Use the elephant seal track data bundled with the package: ellie &lt;- SOmap_data$mirounga_leonina ## construct and plot the map SOmap_auto(ellie$lon, ellie$lat) Just a blank map to which you could add other things: SOmap_auto(ellie$lon, ellie$lat, input_points = FALSE, input_lines = FALSE) You can pass a raster as input data, but note that it won’t plot the raster (it uses its extent to infer an appropriate extent for the map): SOmap_auto(xr) But we can add the raster if we wish: SOmap_auto(xr) SOplot(xr, col = my_cmap) We can force a particular projection: SOmap_auto(xr, target = &quot;laea&quot;, centre_lon = 147, centre_lat = -42) SOplot(xr, col = my_cmap) Same but by supplying a full proj4 string to target: SOmap_auto(xr, target = &quot;+proj=laea +lat_0=-42 +lon_0=147&quot;) SOplot(xr, col = my_cmap) See the SOmap_auto vignette for more examples. 4.3.3 Plotting via ggplot2 The SOmap and SOmap_auto functions do their plotting using base graphics. If you are more comfortable working with ggplot2, this is also possible. The SOgg function takes an object created by one of those functions (using base graphics) and converts it to use ggplot2 graphics instead. As with other SOmap functions, this returns an object (of class SOmap_gg or SOmap_auto_gg) that contains all of the information needed to generate the map. Printing or plotting this object will cause it to construct a ggplot object. Printing or plotting that object will cause it to be drawn to the graphics device, just like any other ggplot object. myplot &lt;- SOmap() myplotgg &lt;- SOgg(myplot) ## creates a SOmap_gg object class(myplotgg) ## [1] &quot;SOmap_gg&quot; my_ggplot &lt;- plot(myplotgg) ## creates a ggplot object class(my_ggplot) ## [1] &quot;gg&quot; &quot;ggplot&quot; plot(my_ggplot) ## plot it Or in one step (this will cause myplot to be converted to SOmap’s internal gg format, then a ggplot object constructed from that, then that object will be plotted): SOgg(myplot) 4.3.4 Modifying map objects (advanced usage) 4.3.4.1 Modifying base graphics maps Calls to SOmap(), SOmanagement(), SOmap_auto() return an object of class SOmap, SOmap_management, or SOmap_auto. These objects contain all of the data and plotting instructions required to draw the map. Calling print() or plot() on one of these objects will cause that code to be executed, and the object to be drawn in the current graphics device. Hence, calling SOmap() directly without assigning the result to a variable will make it appear in the graphics device, because the returned object is being printed to the console (and thus triggering the print method). But you can also assign the result to a variable, e.g. myplot &lt;- SOmap() and then explicitly plot the object with plot(myplot). The advantage of this is that you can potentially manipulate the myplot object to make changes to the map before plotting it. Note, this is likely to be fragile. Proceed at your own risk! mymap &lt;- SOmap() names(mymap) ## [1] &quot;projection&quot; &quot;target&quot; &quot;straight&quot; &quot;trim&quot; ## [5] &quot;bathy&quot; &quot;box&quot; &quot;plot_sequence&quot; &quot;coastline&quot; ## [9] &quot;ice&quot; &quot;outer_mask&quot; &quot;bathy_legend&quot; &quot;border&quot; The object contains a plot_sequence component, which defines the order in which each part of the plot is drawn. The other components of the object contain the code required to draw each part. Take e.g. the ice component (this is the ice shelves, glacier tongues, etc). This is a list (in this case with only one element). Each element of the list specifies a function to run along with arguments to pass to it: str(mymap$ice) ## List of 1 ## $ :List of 2 ## ..$ plotfun : chr &quot;plot&quot; ## ..$ plotargs:List of 4 ## .. ..$ x :sfc_POLYGON of length 354; first list element: List of 1 ## .. .. ..$ : num [1:5, 1:2] 1022981 1026000 1021994 1021935 1022981 ... ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; ## .. ..$ col : logi NA ## .. ..$ border: chr &quot;black&quot; ## .. ..$ add : logi TRUE ## ..- attr(*, &quot;class&quot;)= chr &quot;SO_plotter&quot; We can modify the function and/or its arguments: mymap$ice[[1]]$plotargs$col &lt;- &quot;green&quot; plot(mymap) We can remove entire components: temp &lt;- mymap temp$coastline &lt;- NULL temp$ice &lt;- NULL plot(temp) But note that some elements are required (in particular, the bathymetry layer can’t currently be removed because the code that draws this is also the code that creates the plot). This code would fail (not run here): temp &lt;- mymap temp$bathy &lt;- NULL plot(temp) However, we could replace the bathymetry data with another raster object. We need to be careful about the extent and projection of this raster. For example, simply replacing the bathymetry raster with the ice raster (which has the same polar stereographic projection but smaller extent) gives: temp &lt;- mymap temp$bathy[[1]]$plotargs$x &lt;- ice temp$bathy_legend &lt;- NULL plot(temp) But if we extend the ice raster to match the map extent: temp &lt;- mymap temp$bathy[[1]]$plotargs$x &lt;- raster::extend(ice, mymap$target) temp$bathy_legend &lt;- NULL plot(temp) 4.3.4.2 Modifying ggplot maps We can modify ggplot2-based maps at two levels. 4.3.4.2.1 Modifying the ggplot object. Remember that printing or plotting a SOmap_gg object produces a ggplot object. This can be modified by adding e.g. layers or themes just like a normal ggplot. Remember to load the ggplot2 library now that we are using ggplot2 functions directly. library(ggplot2) my_ggplot + geom_point(data = as.data.frame(my_points), aes(lon, lat, colour = z), size = 3) + scale_colour_distiller(palette = &quot;Spectral&quot;) Multiple rasters or multiple sets of points gets tricky if they are on different scales, because ggplot2 is only designed to work with a single colour scale per geometry type. You can try your luck with the ggnewscale or relayer packages, although both are in a fairly experimental stage of development. ## remotes::install_github(&quot;clauswilke/relayer&quot;) library(relayer) plot(SOgg(SOmap(straight = TRUE))) + rename_geom_aes(geom_raster(data = as.data.frame(SOproj(xr), xy = TRUE), aes(x = x, y = y, fill2 = val)), new_aes = c(fill = &quot;fill2&quot;)) + scale_fill_gradientn(aesthetics = &quot;fill2&quot;, colors = my_cmap, na.value = NA, name = &quot;My variable&quot;, guide = &quot;legend&quot;) ## remotes::install_github(&quot;eliocamp/ggnewscale&quot;) library(ggnewscale) plot(SOgg(SOmap(straight = TRUE))) + new_scale_fill() + geom_raster(data = as.data.frame(SOproj(xr), xy = TRUE), aes(x = x, y = y, fill = val)) + scale_fill_gradientn(colors = my_cmap, na.value = NA, name = &quot;My variable&quot;) 4.3.4.2.2 Modifying the SOmap_gg object SOmap_gg objects are similar in structure to SOmap objects, in that they contain all of the data and plotting instructions required to draw the map: names(myplotgg) ## [1] &quot;projection&quot; &quot;target&quot; &quot;straight&quot; &quot;trim&quot; ## [5] &quot;init&quot; &quot;bathy&quot; &quot;coord&quot; &quot;plot_sequence&quot; ## [9] &quot;scale_fill&quot; &quot;bathy_legend&quot; &quot;coastline&quot; &quot;ice&quot; ## [13] &quot;axis_labels&quot; &quot;theme&quot; &quot;border&quot; However, instead of base plotting functions, SOmap_gg objects use ggplot2 function calls, e.g.: myplotgg$ice[[1]]$plotfun ## [1] &quot;ggplot2::geom_sf&quot; We can modify these function and/or arguments in a similar manner to SOmap objects. myplotgg$ice[[1]]$plotargs$fill &lt;- &quot;green&quot; plot(myplotgg) Or remove the bathymetric raster layer: temp &lt;- myplotgg temp$bathy &lt;- NULL temp$bathy_legend &lt;- NULL plot(temp) Or replace it with a different raster (use the ice raster as an example): temp &lt;- myplotgg ## convert ice raster to suitable data.frame ice_raster_as_df &lt;- raster::as.data.frame(SOproj(ice), xy = TRUE) names(ice_raster_as_df)[3] &lt;- &quot;ice&quot; ## add this to our object in place of bathy temp$bathy &lt;- SO_plotter(plotfun = &quot;ggplot2::geom_raster&quot;, plotargs = list(data = ice_raster_as_df, mapping = aes_string(fill = &quot;ice&quot;)) ) ## change the colour scale temp$scale_fill[[1]]$plotargs &lt;- list(colours = my_cmap, na.value = &quot;#FFFFFF00&quot;, guide = FALSE) ## remove the bathy legend temp$bathy_legend &lt;- NULL plot(temp) 4.4 Supporting data for maps When constructing maps, we commonly want to show features like oceanographic fronts, ice extent, coastline, place names, and MPA boundaries. There are a few sources of such data: some layers are bundled into SOmap, see the SOmap::SOmap_data object antanym provides access to the SCAR Composite Gazetteer of place names the quantarcticR package provides access to Quantarctica data layers. 4.4.1 quantarcticR Note, this package is still in development, so the usage as shown here might change in later versions. Install if needed: remotes::install_github(&quot;SCAR-sandpit/quantarcticR&quot;) Example usage: library(quantarcticR) ds &lt;- qa_datasets() ## all available layers head(ds) ## more info about a particular layer my_layer &lt;- qa_dataset(&quot;Median sea ice extent 1981-2010&quot;) my_layer ## fetch the actual data for that layer layer_data &lt;- qa_get(my_layer) ## plot it plot(layer_data[layer_data$MONTH == &quot;October&quot;, ]) ## or add to a SOmap SOmap(trim = -50, border_width = 0.5) SOplot(layer_data[layer_data$MONTH == &quot;October&quot;, ], col = &quot;red&quot;) 4.4.2 antanym See the overview article. "]
]
