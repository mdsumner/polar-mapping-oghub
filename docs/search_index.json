[
["index.html", "Challenges working with data in polar regions 1 About this 1.1 Description and objectives", " Challenges working with data in polar regions Michael Sumner 1 About this This workshop is for R users interested in mapping in polar regions. This resource is published online at https://mdsumner.github.io/polar-mapping-oghub/. The source code to create this resource is available on Github at https://github.com/mdsumner/polar-mapping-oghub. 1.1 Description and objectives Polar regions present specific problems for broad-scale mapping that often make it very hard to make a simple map from standard data types. Although generic tools are available for reprojecting coordinates and vector and raster data, it’s often not straightforward in practice especially over large regions and in polar areas. Problems are caused by compromises made for global data sets, wrapping problems at the anti-meridian and poles, the availability and sometimes assumptions by software authors. Most problems occur with broad-scale, hemisphere-wide maps and while these are less commonly used for analysis, they are used to prototype and trouble-shoot workflows. Common knowledge about projections and choosing them for particular purposes is not widely shared, even though they are very powerful for visualization and analysis at any scale. This R session will explain the fundamentals of some of these problems and the issues involved with projections, visualizations, analyses and measurements and provide techniques for using map projections in polar regions. We will also introduce some some emerging tools that aim to make life easier and ease the process of working with map projections. Installation instructions: https://mdsumner.github.io/polar-mapping-oghub/getting-set-up.html#getting-set-up Datasets in use: Coastline from maps package, wrld_simpl polygons from maptools package, example sea surface temperature data (OISST 2019-08-06), example sea ice concentration data (NSIDC 2019-08-06), aes_zone and aes_zone_ll regional polar polygons as used in Trebilco et al. (2019) 1.1.1 References Trebilco et al. (2019, in press) Assessing status and trends of open ocean habitats: a regionally resolved approach and Southern Ocean application. Ecological Indicators M.J. Brasier, A. Constable, J. Melbourne-Thomas, R. Trebilco, H. Griffiths, A. Van de Putte, M. Sumner (2019) Observations and models to support the first Marine Ecosystem Assessment for the Southern Ocean (MEASO), Journal of Marine Systems, 197, https://doi.org/10.1016/j.jmarsys.2019.05.008 Dale Maschette, Michael Sumner and Ben Raymond (2019). SOmap: Southern Ocean maps. R package version 0.4.0. https://australianantarcticdivision.github.io/SOmap/ "],
["getting-set-up.html", "2 Getting Set Up", " 2 Getting Set Up We need the following packages installed, using remotes is the best way to install as it will not re-install any package if it’s already up to date. ## make sure we have the packages we need if (!requireNamespace(&quot;remotes&quot;, quietly = TRUE)) { install.packages(&quot;remotes&quot;) } req1 &lt;- c(&quot;ggplot2&quot;, &quot;maps&quot;, &quot;maptools&quot;, &quot;raster&quot;, &quot;sp&quot;, &quot;dplyr&quot;, &quot;rgdal&quot;) remotes::install_cran(req1) Obtain some extra data sets that will be used in this session. if (!file.exists(&quot;polar-mapping.Rdata&quot;)) { download.file(&quot;https://github.com/mdsumner/polar-mapping-oghub/raw/master/data-raw/polar-mapping.Rdata&quot;, &quot;polar-mapping.Rdata&quot;, mode = &quot;wb&quot;) } load(&quot;polar-mapping.Rdata&quot;) "],
["polar-maps.html", "3 Polar maps 3.1 Mapping in R 3.2 Exercises 01 3.3 Let’s use the maps data! 3.4 Reprojecting to polar regions 3.5 Demonstration of the projection concept", " 3 Polar maps What is required for mapping in polar regions? shape-feature orientations, the dateline and the poles handling of data in long-lat, understanding of metrics and shape (area, length, angle) projected maps can be very hard to do, each has its own issues quantities like vector fields conventions for global data -180/180, 0/360 3.1 Mapping in R library(sp) library(raster) library(maps) library(rgdal) ## rgdal: version: 1.4-4, (SVN revision 833) ## Geospatial Data Abstraction Library extensions to R successfully loaded ## Loaded GDAL runtime: GDAL 2.4.2, released 2019/06/28 ## Path to GDAL shared files: /usr/share/gdal ## GDAL binary built with GEOS: TRUE ## Loaded PROJ.4 runtime: Rel. 5.2.0, September 15th, 2018, [PJ_VERSION: 520] ## Path to PROJ.4 shared files: (autodetected) ## Linking to sp version: 1.3-1 data(&quot;wrld_simpl&quot;, package = &quot;maptools&quot;) The oldest general mapping tool in R is the maps package. It has a simple whole-world coastline data set for immediate use. maps::map() The data underlying this live map is available by capturing the output as an actual object. If we look carefully at the southern edge and the eastern edge, notice that the coastline for Antarctica does not extend to the south pole, and the Chukotka region of Russia east of 180 longitude is not in the western part of the map. maps_c &lt;- maps::map(plot = FALSE) lonlat &lt;- cbind(maps_c$x, maps_c$y) plot(lonlat, pch = &quot;+&quot;, cex = 0.4, axes = FALSE) lines(lonlat, col = &quot;dodgerblue&quot;) abline(h = c(-90, 90), v = c(-180, 180)) A very similar and slightly more modern data set is available in the maptools package. (It’s not sensible use maps or maptools for coasline or country boundary data, but they are handy for exploring concepts ). data(&quot;wrld_simpl&quot;, package = &quot;maptools&quot;) plot(wrld_simpl) This data set aligns exactly to the conventional -180/180 -90/90 extent of the longitude/latitude projection. plot(0, type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, xlim = c(-180, 180), ylim = c(-90, 90)) rect(xleft = -180, ybottom = -90, xright = 180, ytop = 90, border = &quot;darkred&quot;, lwd = 4, lty = 2) plot(wrld_simpl, add = TRUE) 3.2 Exercises 01 How can we find the longitude and latitude ranges of the maps data maps_c and the maptools data wrld_simpl? Can we draw polygons with a fill colour with the maps package? Answer 1: range(m$x, na.rm = TRUE) range(m$y, na.rm = TRUE) also m$range Answer 2: polygon(lonlat, col = &quot;grey&quot;) does not work, and map(mp, fill = TRUE, col = &quot;grey&quot;) does not work, but maps::map(fill = TRUE, col = &quot;grey&quot;) does seem to work. What’s going on? Look at the very south-eastern corner of the map. The “coastline” has been extended to the very south boundary of the available area. plot(0, type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, xlim = c(-150, 180), ylim = c(-90, -60)) plot(wrld_simpl, add = TRUE, col = &quot;grey&quot;) rect(xleft = -180, ybottom = -90, xright = 180, ytop = 90, border = &quot;darkred&quot;, lwd = 4, lty = 2) maps::map(add = TRUE, col = &quot;dodgerblue&quot;, lwd = 3) When we add the old maps coastline see that it does not extend to 90S and it does not traverse the southern boundary. One reason for this is that if we choose a projection where the east and west edges of the Antarctic coastline meet then we get what looks a fairly clean join. ## scale factor f &lt;- 3e6 plot(rgdal::project(lonlat, &quot;+proj=laea +lat_0=-90 +datum=WGS84&quot;), asp = 1, type = &quot;l&quot;, xlim = c(-1, 1) * f, ylim = c(-1, 1) * f, xlab = &quot;&quot;, ylab = &quot;&quot;) If we try the same with wrld_simpl it’s not as neat. We have a strange “seam” that points exactly to the south pole (our projection is centred on longitude = 0, and latitude = -90. plot(sp::spTransform(wrld_simpl, &quot;+proj=laea +lat_0=-90 +datum=WGS84&quot;), asp = 1, xlim = c(-1, 1) * f, ylim = c(-1, 1) * f, xlab = &quot;&quot;, ylab = &quot;&quot;, lwd = 3) abline(v = 0, h = 0, lty = 2, col = &quot;grey&quot;) 3.3 Let’s use the maps data! In maps_c we have the maps data structure, and this looks promising. str(maps_c) ## List of 4 ## $ x : num [1:82403] -69.9 -69.9 -69.9 -70 -70.1 ... ## $ y : num [1:82403] 12.5 12.4 12.4 12.5 12.5 ... ## $ range: num [1:4] -180 190.3 -85.2 83.6 ## $ names: chr [1:1627] &quot;Aruba&quot; &quot;Afghanistan&quot; &quot;Angola&quot; &quot;Angola:Cabinda&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;map&quot; mp &lt;- maps_c pxy &lt;- rgdal::project(lonlat, &quot;+proj=laea +lat_0=-90 +datum=WGS84&quot;) mp$x &lt;- pxy[,1] mp$y &lt;- pxy[,2] mp$range &lt;- c(range(mp$x,na.rm = TRUE), range(mp$y, na.rm = TRUE)) mp$range ## [1] -12709814 12704237 -12576156 12470787 plot(c(-1, 1) * f, c(-1, 1) * f, type = &quot;n&quot;, asp = 1) maps::map(mp, add = TRUE) ## but it doesn&#39;t take much to go awry plot(c(-1, 1) * f, c(-1, 1) * f, type = &quot;n&quot;, asp = 1) maps::map(mp, add = TRUE, fill = TRUE, col = &quot;grey&quot;) The problem is that the maps database has enough internal structure to join lines correctly, with NA gaps between different connected linestrings, but not enough to draw these things as polygons. A similar problem occurs in the default projection. While wrld_simpl has been extend by placing two dummy coordinates at the east and west versions of the south pole, this data set does not have those. We have to look quite carefully to understand what is happening, but this is wrapping around overlapping itself and so close to the southern bound we barely notice. plot(0, type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, xlim = c(-180, -110), ylim = c(-90, -60)) rect(xleft = -180, ybottom = -90, xright = 180, ytop = 90, border = &quot;darkred&quot;, lwd = 4, lty = 2) maps::map(add = TRUE,col = &quot;grey&quot;, fill = TRUE) maps::map(col = &quot;grey&quot;, fill = TRUE) mpmerc &lt;- maps_c pxy &lt;- rgdal::project(lonlat, &quot;+proj=merc +datum=WGS84&quot;) mpmerc$x &lt;- pxy[,1] mpmerc$y &lt;- pxy[,2] mpmerc$range &lt;- c(range(mpmerc$x,na.rm = TRUE), range(mpmerc$y, na.rm = TRUE)) mpmerc$range ## [1] -20037508 20037508 -20179524 18351859 ## the catastrophe made a little clearer plot(0, xlim = range(mpmerc$range[1:2]), ylim = c(mpmerc$range[1], 0)) maps::map(mpmerc, fill = TRUE, col = &quot;grey&quot;, add = TRUE) 3.4 Reprojecting to polar regions In essence it should be easy, but details really matter. sst &lt;- raster::raster(system.file(&quot;nc/reduced.nc&quot;, package = &quot;stars&quot;, mustWork = TRUE)) ## Loading required namespace: ncdf4 ## Warning in .varName(nc, varname, warn = warn): varname used is: sst ## If that is not correct, you can set it to one of: sst, anom, err, ice plot(raster::projectRaster(sst, crs = &quot;+proj=laea +lat_0=-90&quot;)) ## Warning in rgdal::rawTransform(projfrom, projto, nrow(xy), xy[, 1], xy[, : ## 48 projected point(s) not finite ## Warning in rgdal::rawTransform(projto_int, projfrom, nrow(xy), xy[, 1], : ## 6211 projected point(s) not finite plot(raster::projectRaster(rotate(sst), crs = &quot;+proj=laea +lat_0=-90&quot;)) ## Warning in rgdal::rawTransform(projfrom, projto, nrow(xy), xy[, 1], xy[, : ## 48 projected point(s) not finite ## Warning in rgdal::rawTransform(projto_int, projfrom, nrow(xy), xy[, 1], : ## 6213 projected point(s) not finite Loxodromes need densifying, and not along great circles. The pole is undefined in Mercator. Sensible polar projections are stereographic and Lambert Azimuthal Equal Area. These are more or less identical over a large area, so knowing what is in use really matters! data(&quot;wrld_simpl&quot;, package = &quot;maptools&quot;) laea &lt;- &quot;+proj=laea +lon_0=0 +lat_0=-90 +datum=WGS84&quot; stere &lt;- &quot;+proj=stere +lon_0=0 +lat_0=-90 +datum=WGS84&quot; wm &lt;- wrld_simpl[coordinates(wrld_simpl)[,2] &lt; 30, ] ## remember that plotting in R is usually *NOT* coordinate system aware ... plot(spTransform(wm, laea)) plot(spTransform(wm, stere), add = TRUE, border = &quot;firebrick&quot;) points(0, 0, cex = 40) This video explains the Lambert Azimuthal Equal Area projection: https://www.youtube.com/watch?v=quzIU4nL9ig (crux at 2:25 with the spherical shells). 3.5 Demonstration of the projection concept rgl plots Stereographic, LAEA, Orthographic "],
["data-handling-in-polar-regions.html", "4 Data handling in polar regions 4.1 Overlay between different projections 4.2 Build an index betweeen the raw raster data and the polar map regions", " 4 Data handling in polar regions load(&quot;polar-mapping.Rdata&quot;) ## see getting-set-up library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:raster&#39;: ## ## intersect, select, union ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union In practice, these kinds of problems in polar data mean that careful choices be made. For an involved whole-ecosystem assessment publication we generated a partition of the marine region of the Southern Ocean. plot(aes_zone, col = aes_zone$colour) abline(v = 0, lty = 2) This was easy for mapping sea ice concentration, we have daily remote sensing maps of southern ocean sea ice and it’s trivial to reproject our polygons onto those. library(raster) plot(sea_ice) plot(spTransform(aes_zone, raster::projection(sea_ice)), add = TRUE) But when it comes to sea surface temperature, these data have a number of issues. One is that the data is natively in [0, 360] longitude range and if we project these data to our polar map we lose the western hemisphere. rtemp &lt;- raster(aes_zone, res = 25000) plot(projectRaster(sea_temp, rtemp)) ## Warning in rgdal::rawTransform(projfrom, projto, nrow(xy), xy[, 1], xy[, : ## 53 projected point(s) not finite The solution to that problem is to shift the part of the raster that is over the dateline back to the west sea_temp180 &lt;- raster::rotate(sea_temp) plot(projectRaster(sea_temp180, rtemp)) ## Warning in rgdal::rawTransform(projfrom, projto, nrow(xy), xy[, 1], xy[, : ## 53 projected point(s) not finite plot(aes_zone, add = TRUE) On the face of it this means we now have an easy job, simply project every sea surface temperature raster onto this polar map and then do the extraction. But, this is going to be slow, it’s a lot of work to reproject 10000+ raster grids, and it inevitably involves resampling (remodelling) of the underlying data, imposing assumptions about what the data means. This is more important for other quantities like wind speeds and water flow directions, but is for the same ultimate reasons. 4.1 Overlay between different projections This is what the overlay process would be like, and we might think we can inverse-transform our polar polygons to this. plot(sea_temp180) plot(aes_zone_ll, add =TRUE) But, it doesn’t look good. This is because the polar region that crosses the dateline is a single polygon, but in this projection it must be split in two pieces. This is why there is two objects aes_zone and aes_zone_ll. It can be a bit of work to construct these two versions but in our experience it really made things simpler, there’s simply a one-to-one relationship between the to data sets, one in longitude/latitude, and one in polar map coordinates. plot(sea_temp180) plot(spTransform(aes_zone, raster::projection(sea_temp180)), add =TRUE) 4.2 Build an index betweeen the raw raster data and the polar map regions This is a really powerful trick for processing spatial data in R, and boils down to performing the extraction from the raster data in the native grid. Every pixel is the sea surface temperature data has a unique relationship with each polygon, it either belongs inside a single polygon or not. So we create this index by rasterizing the polygons into the grid. This seems backwards, but it means we now now which polygon every pixel belongs to. aes_zone_ll$row &lt;- 1:nrow(aes_zone_ll) raster_polys &lt;- fasterize::fasterize(sf::st_as_sf(aes_zone_ll), sea_temp180, field = &quot;row&quot;) plot(raster_polys) That is all the “geometry lookup” work required done. We can produce an index between raster cell and polygon in a simple table. cell &lt;- tibble::tibble(polygon = raster::values(raster_polys), cell = 1:ncell(raster_polys)) cell ## # A tibble: 1,036,800 x 2 ## polygon cell ## &lt;dbl&gt; &lt;int&gt; ## 1 NA 1 ## 2 NA 2 ## 3 NA 3 ## 4 NA 4 ## 5 NA 5 ## 6 NA 6 ## 7 NA 7 ## 8 NA 8 ## 9 NA 9 ## 10 NA 10 ## # … with 1,036,790 more rows ## we don&#39;t need very cell, the most southerly region is NA as is anything north of 20S cell &lt;- dplyr::filter(cell, !is.na(polygon)) cell ## # A tibble: 230,383 x 2 ## polygon cell ## &lt;dbl&gt; &lt;int&gt; ## 1 12 691201 ## 2 12 691202 ## 3 12 691203 ## 4 12 691204 ## 5 12 691205 ## 6 12 691206 ## 7 12 691207 ## 8 12 691208 ## 9 12 691209 ## 10 12 691210 ## # … with 230,373 more rows To extract the values for this index we use cell and this takes very little time: cell$sst &lt;- raster::extract(sea_temp180, cell$cell) cell %&gt;% dplyr::group_by(polygon) %&gt;% dplyr::summarize(mean = mean(sst, na.rm = TRUE), sd = sd(sst, na.rm = TRUE), min = min(sst, na.rm = TRUE), max = max(sst, na.rm = TRUE)) ## # A tibble: 12 x 5 ## polygon mean sd min max ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1.01 3.59 -1.80 13.6 ## 2 2 -1.76 0.0760 -1.80 -1.07 ## 3 3 13.5 4.36 -1.37 23.3 ## 4 4 0.435 2.10 -1.80 5.09 ## 5 5 -1.69 0.114 -1.79 -1.16 ## 6 6 9.96 3.82 2.92 19.3 ## 7 7 1.91 3.60 -1.80 15.5 ## 8 8 -1.75 0.0481 -1.80 -1.47 ## 9 9 12.2 3.59 1.37 21.1 ## 10 10 -0.440 2.02 -1.80 9.10 ## 11 11 -1.76 0.0367 -1.80 -1.48 ## 12 12 11.3 4.66 -0.770 22.6 If we ran this using raster directly, it takes quite some time for a single layer and a single statistic, and if we have a lot of time slices it will really add up. system.time(raster::extract(sea_temp180, aes_zone_ll, fun = mean, na.rm = TRUE)) ## user system elapsed ## 18.331 0.164 18.502 "],
["somap.html", "5 SOmap 5.1 Circumpolar maps 5.2 Adding points", " 5 SOmap The SOmap package is intended to solve some of these problems, and provide an easier way to produce nice-looking maps of Antarctica and the Southern Ocean. It is primarily focused on maps in polar stereographic projection (although the SOmap_auto function extends this to other projections). SOmap won’t necessarily get you exactly the map you want. But if it doesn’t, it should hopefully get you close enough that you can make modifications to suit your exact purposes. Please bear in mind that SOmap is still in development, and so its functionality (function parameters and/or behaviour) may change. By default, SOmap works with base graphics (and associated functionality from packages such as raster and sp). It is also possible to work with ggplot2-based graphics, as described below. Start by loading the SOmap package: library(SOmap) ## also define a colour map to use for some examples my_cmap &lt;- colorRampPalette(c(&quot;#4D4140&quot;, &quot;#596F7E&quot;, &quot;#168B98&quot;, &quot;#ED5B67&quot;, &quot;#E27766&quot;, &quot;#DAAD50&quot;, &quot;#EAC3A6&quot;))(51) DRAFT, this might be illustrated or not 5.1 Circumpolar maps A basic circumpolar map in polar stereographic projection: SOmap() SOmanagement() provides a number of contextual layers such as MPA boundaries and management zones. SOmap(trim = -40) ## plot to 40S ## add the exclusive economic zones management layer SOmanagement(eez = TRUE) 5.2 Adding points ## some longitude/latitude data library(sp) my_points_ll &lt;- data.frame(lon = seq(0, 350, by = 10), lat = -55, z = runif(36)) coordinates(my_points_ll) &lt;- c(&quot;lon&quot;, &quot;lat&quot;) projection(my_points_ll) &lt;- &quot;+proj=longlat +datum=WGS84&quot; This needs to be reprojected to match our map before plotting. The SOproj function does this: ## reproject to our SOmap projection my_points &lt;- SOproj(my_points_ll) ## and plot SOmap() plot(my_points, col = &quot;blue&quot;, add = TRUE) Or use SOplot to reproject and plot in one step: SOmap() SOplot(my_points_ll, col = &quot;blue&quot;) "]
]
